{-# LANGUAGE FlexibleContexts #-}
module Simulator
  ( toAntInstructions
  , runNRounds
  , initGameState
  , GameState(..)
  , (=~=)
  ) where

import           Control.Lens
import           Control.Monad       (replicateM_)
import           Control.Monad.State
import           Data.Array.IO
import           Data.Char           (isDigit)
import qualified Data.Map            as M
import qualified Data.Set            as S

import           Simulator.Base
import           Ant.Monad
import           Ant.Base

-- | Generate AntInstructions from a Program.
-- This leaves in IO because AntInstructions is a IOArray.
toAntInstructions :: Label l
                  => [Command l]
                  -> IO AntInstructions
toAntInstructions prog =
   newListArray (0 , length prog - 1) $ map (fmap toInt) prog

--progToCommand = (map (fmap toInt . snd) . M.toAscList $ cmds)

-- | Compare two GameState for Equivalencea.
-- Because under the hood uses IOArray this has
-- to leave in IO.
(=~=) :: GameState -> GameState -> IO Bool
gs1 =~= gs2 = liftM2 (==) (getElems (world gs1)) (getElems (world gs2))

runNRounds :: Int -> GameState -> IO GameState
runNRounds n = runSimulator (replicateM_ n oneRound)

-- | Get a initial game state.
initGameState :: Label l
              => Int         -- ^ Random seed
              -> String      -- ^ World as generated by mkWorld
              -> [Command l] -- ^ Program
              -> AntInstructions -- ^ Default black ant program
              -> IO GameState
initGameState seed world prog blackProg =
   do theWorld   <- mkWorld world
      redInstr   <- toAntInstructions prog

      (pm, foodPos, foodParticles) <- populateWorld theWorld

      return $ GameState
         { world             = theWorld
         , redInstructions   = redInstr
         , blackInstructions = blackProg
         , antPositions      = pm
         , randoms           = randomStream seed
         , roundNumber       = 0
         , foodAdmin         = noFood { remaining = foodParticles, locations = foodPos }
         }

-- | Run the simulation for one round.
oneRound :: Sim ()
oneRound =
  do modify (\game -> game {roundNumber = roundNumber game + 1})
     pm   <- gets antPositions
     list <- liftIO $ getAssocs pm
     mapM_ step list

-- | Populate a world placing Ants as defined in the specification
populateWorld :: World -> IO (AntPositions, S.Set Pos, Int)
populateWorld theWorld =
   do list <- getAssocs theWorld
      (nrOfAnts, pm, foodSet, nrOfFood) <- foldM op (0, [], S.empty, 0) list
      arr <- newListArray (0, nrOfAnts - 1) (reverse pm)
      return (arr, foodSet, nrOfFood)
 where
   op this@(i, pm, fm, f) (pos, cell)
      | food cell > 0 = return (i, pm, S.insert pos fm, f + food cell)
      | otherwise =
           case anthill cell of
              Nothing ->
                 return this
              Just c ->
                 do writeArray theWorld pos (cell { antInCell = Just (makeAnt i c) })
                    return (i+1, Just pos : pm, fm, f)

-- | Make a single Ant
makeAnt :: Int -> AntColor -> Ant
makeAnt i c = Ant
  { antId        = i
  , antColor     = c
  , antState     = 0
  , antResting   = 0
  , antDirection = 0
  , antHasFood   = False
  }

-- | Make a world out of a String.
-- The specific format of the String to be a valid
-- world is explained in the specification.
mkWorld :: String -> IO World
mkWorld s =
  case map words (lines s) of
    [dimX] : [dimY] : rest | isNum dimX && isNum dimY ->
      do let cells = map stringToCell (concat rest)
             dx    = read dimX
             dy    = read dimY
         w <- newListArray (Pos 0 0, Pos (dx-1) (dy-1)) cells
         if length cells /= dx * dy
            then error "invalid world"
            else return w
    _ -> error "invalid world"


stringToCell :: String -> Cell
stringToCell s =
   case s of
      ['#'] -> stdCell { cellType = Rocky }
      ['.'] -> stdCell
      ['+'] -> stdCell { anthill = Just Red }
      ['-'] -> stdCell { anthill = Just Black }
      [_] | isNum s -> stdCell { food = read s }
      _ -> error ("invalid cell in world file: " ++ show s)

stdCell :: Cell
stdCell = Cell
  { antInCell    = Nothing
  , cellType     = Clear
  , food         = 0
  , anthill      = Nothing
  , markersRed   = noMarkers
  , markersBlack = noMarkers
  }

isNum :: String -> Bool
isNum s = all isDigit s && not (null s)
